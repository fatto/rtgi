#extension GL_NV_shader_atomic_float : require

layout(local_size_x = 8, local_size_y = 8) in;

uniform uint voxel_frag_count;
uniform uint level;
uniform uint voxel_dim;

// layout(binding = 0) uniform usamplerBuffer voxel_position;
// layout(binding = 1) uniform usamplerBuffer voxel_diffuse;
// layout(binding = 2) uniform samplerBuffer voxel_normal;

// layout(binding = 0, r32ui) uniform uimageBuffer octree_buffer;

// layout(binding = 1, r32ui) uniform uimageBuffer octree_diffuse_r;
// layout(binding = 2, r32ui) uniform uimageBuffer octree_diffuse_g;
// layout(binding = 3, r32ui) uniform uimageBuffer octree_diffuse_b;
// layout(binding = 4, r32ui) uniform uimageBuffer octree_diffuse_a;

// layout(binding = 5, r32f) uniform imageBuffer octree_normal_x;
// layout(binding = 6, r32f) uniform imageBuffer octree_normal_y;
// layout(binding = 7, r32f) uniform imageBuffer octree_normal_z;

layout(binding = 0, rgb10_a2ui) uniform uimageBuffer voxel_position;
layout(binding = 1, rgba8ui) uniform uimageBuffer voxel_diffuse;
layout(binding = 2, rgba32f) uniform imageBuffer voxel_normal;

layout(binding = 3, r32ui) uniform uimageBuffer octree_buffer;

layout(binding = 4, r32ui) uniform uimageBuffer octree_diffuse;

layout(binding = 5, r32f) uniform imageBuffer octree_normal;

// layout(binding = 0, rgb10_a2ui) uniform uimageBuffer voxel_position;
// layout(binding = 1, rgba8ui) uniform uimageBuffer voxel_diffuse;
// layout(binding = 2, rgba32f) uniform imageBuffer voxel_normal;

// layout(binding = 3, r32ui) uniform uimageBuffer octree_buffer;

// layout(binding = 4, r32ui) uniform uimageBuffer octree_diffuse_r;
// layout(binding = 5, r32ui) uniform uimageBuffer octree_diffuse_g;
// layout(binding = 6, r32ui) uniform uimageBuffer octree_diffuse_b;
// layout(binding = 7, r32ui) uniform uimageBuffer octree_diffuse_a;

// layout(binding = 8, r32f) uniform imageBuffer octree_normal_x;
// layout(binding = 9, r32f) uniform imageBuffer octree_normal_y;
// layout(binding = 10, r32f) uniform imageBuffer octree_normal_z;

void main()
{
	uint th_id = gl_GlobalInvocationID.y * 1024 + gl_GlobalInvocationID.x;
	if(th_id >= voxel_frag_count)
		return;

	uvec3 umin = uvec3(0, 0, 0);
	// uvec4 location = texelFetch(voxel_position, int(th_id)); // voxel coordinates of voxel loaded by this thread
	uvec4 location = imageLoad(voxel_position, int(th_id)); // voxel coordinates of voxel loaded by this thread
	uint child_id = 0;
	uint node = imageLoad(octree_buffer, int(child_id)).r;
	uvec3 offset;
	uint voxel_dimension = voxel_dim;

	for(uint i = 0; i < level; ++i)
	{
		voxel_dimension /= 2;
		if((node & 0x80000000) == 0)
		{
			break;
		}

		child_id = (node & 0x7fffffff); // get child id masking out flag bit

		// offset =      clamp(int(1+location.x-umin.x-voxel_dimension), 0, 1);
		// offset += 4 * clamp(int(1+location.y-umin.y-voxel_dimension), 0, 1);
		// offset += 2 * clamp(int(1+location.z-umin.z-voxel_dimension), 0, 1);
		// child_id += offset;

		offset = clamp(ivec3(1 + location.xyz - umin - voxel_dimension), 0, 1);
		child_id += offset.x + 4 * offset.y + 2 * offset.z;

		// umin.x += voxel_dimension * clamp(int(1+location.x-umin.x-voxel_dimension), 0, 1);
		// umin.y += voxel_dimension * clamp(int(1+location.y-umin.y-voxel_dimension), 0, 1);
		// umin.z += voxel_dimension * clamp(int(1+location.z-umin.z-voxel_dimension), 0, 1);

		umin += voxel_dimension * offset;

		node = imageLoad(octree_buffer, int(child_id)).r;
	}
	uvec4 colour = uvec4(imageLoad(voxel_diffuse, int(th_id)));
	int image_index = int(child_id);
	int rgba_index = image_index*4;
	int nxnynz_index = image_index*3;
	imageAtomicAdd(octree_diffuse, rgba_index+0, colour.r);
	imageAtomicAdd(octree_diffuse, rgba_index+1, colour.g);
	imageAtomicAdd(octree_diffuse, rgba_index+2, colour.b);
	imageAtomicAdd(octree_diffuse, rgba_index+3, uint(1));
	// uvec4 colour = texelFetch(voxel_diffuse, int(th_id));
	// imageAtomicAdd(octree_diffuse_r, int(child_id), colour.r);
	// imageAtomicAdd(octree_diffuse_g, int(child_id), colour.g);
	// imageAtomicAdd(octree_diffuse_b, int(child_id), colour.b);
	// imageAtomicAdd(octree_diffuse_a, int(child_id), uint(1));

	vec4 normal = vec4(imageLoad(voxel_normal, int(th_id)));
	imageAtomicAdd(octree_normal, nxnynz_index+0, normal.x);
	imageAtomicAdd(octree_normal, nxnynz_index+1, normal.y);
	imageAtomicAdd(octree_normal, nxnynz_index+2, normal.z);
	// vec4 normal = texelFetch(voxel_normal, int(th_id));
	// imageAtomicAdd(octree_normal_x, int(child_id), normal.x);
	// imageAtomicAdd(octree_normal_y, int(child_id), normal.y);
	// imageAtomicAdd(octree_normal_z, int(child_id), normal.z);
}